%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% m_trace_transform_path_matrix.m
% 
% Utility function that is designed to allow for simple geometric transforma
% -tions of paths in the structured data format generated by m_trace.
% 
% The 'matrix' argument is an arbitrary 3x3 matrix implementing a projective
% transform defined by:
%   s*[x', y', 1]' = matrix * [x, y, 1]'
% where s is an arbitrary scalar factored out of the product to normalize x' and
% y'.
% 
% Patrick Kilcullen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function path_out = m_trace_transform_path_matrix(path, matrix)
    path_out = path;
    is_ray_origin = isfield(path, 'ray_origin');

    if is_ray_origin
        sps = path.ray_origin_subpaths;
    else
        sps = path.subpaths;
    end
        % We handle different subpath fields depending on if the path object is
        % a ray_origin object. The subpath field is ultimately updated for these
        % objects by the simulation to reflect the calculated ray path (this
        % allows graphics updating to be simplified). Thus to move a ray_origin
        % object, we updated the ray_origin_subpaths field, rather than the
        % subpaths field, which is used by the main animation loop to
        % initialize ray_origin data for tracing.

    % Segment data transformations:
    for s=1:numel(sps)
        % subpaths are composed of segments
        for t=1:numel(sps(s).seg_data)
            seg = sps(s).seg_data(t);
            data = seg.data;
            switch seg.type
                case 'B'    % Bezier paths
                    % Data is interleved [x1, y1, x2, y2, ...]
                    for k=1:2:numel(data)
                        xy = matrix * [data(k); data(k+1); 1];
                        data(k)   = xy(1)/xy(3);
                        data(k+1) = xy(2)/xy(3);
                    end
                case 'E'    % Elliptical paths
                    % Compute new center coordinates:
                    cc = matrix * [data(3); data(4); 1];
                    data_t(3) = cc(1);  % new cx
                    data_t(4) = cc(2);  % new cy

                    % Compute new rx and ry:
                    rx = data(1);
                    ry = data(2);
                    ph = data(5);
                    G = matrix(1:2, 1:2) * ...
                        [cos(ph), -sin(ph); sin(ph), cos(ph)] * ...
                        [rx, 0; 0, ry];
                    rx_t = sqrt( G(1,1)^2 + G(2,1)^2 );
                    ry_t = sqrt( G(1,2)^2 + G(2,2)^2 );
                    if rx_t>0
                        ph_t = atan2(G(2,1), G(1,1));
                    else
                        ph_t = atan2(G(2,2), G(1,2));
                    end
                    data_t(1) = rx_t;
                    data_t(2) = ry_t;
                    data_t(5) = ph_t;

                    % Angle ranges are preserved:
                    data_t(6) = data(6);
                    data_t(7) = data(7);
                    
                    data = data_t;
                otherwise
                    error('Unknown segment type.');
            end

            if is_ray_origin
                path_out.ray_origin_subpaths(s).seg_data(t).data = data;
            else
                path_out.subpaths(s).seg_data(t).data = data;
            end
            path_out.redraw_needed = true;
        end
    end
end
